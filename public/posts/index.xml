<rss xmlns:webfeeds="http://webfeeds.org/rss/1.0" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" >
    <channel>
        
        <title>👑 Spencer Woo's Blog</title>
        <link>https://blog.spencerwoo.com/posts/</link>
        <description>Recent content in Posts on LoveIt Theme</description>
        <webfeeds:icon>https://blog.spencerwoo.com/images/avatar.jpeg</webfeeds:icon>
        <generator>Hugo -- gohugo.io</generator>
        
            <language>en</language>
        
        
        
            <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
        
        
            <lastBuildDate>Tue, 26 Nov 2019 11:46:00 +0800</lastBuildDate>
        
        <atom:link href="https://blog.spencerwoo.com/posts/" rel="self" type="application/rss+xml" />
        
            <item>
                <title>IFTTT x Integromat：微博 to Twitter 自动转发的最佳实践</title>
                <link>https://blog.spencerwoo.com/2019/11/weibo-to-twitter/</link>
                <pubDate>Tue, 26 Nov 2019 11:46:00 +0800</pubDate>
                
                <guid>https://blog.spencerwoo.com/2019/11/weibo-to-twitter/</guid>
                <description>&lt;p&gt;IFTTT 网络自动化平台实际上是一个缩写，完全展开的 IFTTT 是「IF this THEN that」- 如果「这」，那么「那」。既然如此，我们利用 IFTTT 就可以实现非常完善的自动化事件处理流程，比如这篇文章我要介绍的就是一个例子：「利用 IFTTT 自动将微博发布的信息同步到 Twitter 上面」的最佳实践。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;🎫 附注：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文介绍方法高度借鉴于这篇文章：&lt;a href=&#34;https://sspai.com/post/51942&#34;&gt;微博同步至 Twitter，这里有更好的方式 - 少数派&lt;/a&gt;，但是本文的介绍方式更为清晰易懂，配置简洁明了，同时也解决了一些如果按照原文直接配置的话会出现的意外问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;heading&#34;&gt;背景与工作原理&lt;/h2&gt;
&lt;p&gt;首先，IFTTT 上面已经有非常多的微博、Twitter 互相自动转发分享的 Applet（就是 IFTTT 的动作），官方甚至都有一个专门的分类，包含了一些基本的微博 → Twitter、Twitter → 微博的动作：&lt;a href=&#34;https://ifttt.com/connect/sina_weibo/twitter&#34;&gt;Connect Sina Weibo to Twitter to unlock powerful experiences&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/26/1W6XTByKsDHpZYe.png&#34; alt=&#34;IFTTT 官方微博 Twitter 同步 Applet&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是单独由 IFTTT 进行「微博 → Twitter」的自动转发有着非常的局限性。IFTTT 无法区分：纯文本原创微博、带图原创微博、以及转发微博这三种微博。如果我们只依赖于 IFTTT 来帮我们进行「微博 → Twitter」转发的话：要么我们只能转发文字 + 原微博链接；要么我们转的带图，但是对于纯文本微博 IFTTT 会发送一张「找不到原图」的 Twitter。因此，今天我们所要介绍的方法，就是利用 Integromat 对 IFTTT 获取到的微博进行路由分流，实现对纯文本微博自动发 IFTTT 纯文本微博转发 Applet、对带图微博自动发 IFTTT 带图微博转发 Applet，并自动过滤掉非原创微博的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/KrjZGPt8zgpQqNF.png&#34; alt=&#34;仅靠 IFTTT 只能单独执行某个转发策略，这不够&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-ifttt--integromat-&#34;&gt;利用 IFTTT 和 Integromat 配合实现路由转发&lt;/h2&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;流程原理&lt;/h3&gt;
&lt;p&gt;目前和微博平台整合最好、最方便的自动化平台就是 IFTTT，因此我们不能丢掉 IFTTT。利用 IFTTT 获取到微博的信息包括：微博文本、微博原链接以及微博图片链接。因此，我们需要做的就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先利用 IFTTT 获取最新发送的微博，包括微博文本、微博原链接和微博图片这三项参数&lt;/li&gt;
&lt;li&gt;通过 HTTP 请求在 Integromat 中触发 Webhook，利用 Integromat 解析 IFTTT 发送来的数据，根据「图片的有无」进行路由分配，调用合适的 IFTTT 动作&lt;/li&gt;
&lt;li&gt;Integromat 调用合适的 IFTTT 动作之后，IFTTT 执行发送 Twitter 的 Applet&lt;/li&gt;
&lt;li&gt;结束 👍&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/27/hX6GfquxD15Kpoy.png&#34; alt=&#34;利用 IFTTT 和 Integromat 配合实现微博 Twitter 转发流程&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们接下来的基本工作就是按步骤对上面介绍的功能在相应的平台上一一进行实现。&lt;/p&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;在一切开始之前，我们需要在 IFTTT 和 Integromat 两个平台上做一些准备工作。&lt;/p&gt;
&lt;h4 id=&#34;-integromat--scenario&#34;&gt;在 Integromat 平台创建 Scenario&lt;/h4&gt;
&lt;p&gt;在 &lt;a href=&#34;https://www.integromat.com&#34;&gt;Integromat&lt;/a&gt; 平台注册登录，在 Scenarios 处点击创建：Create a new scenario，搜索 Webhook 并选择，之后点击 Continue 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/i6zSfaJx4u7kovc.png&#34; alt=&#34;Integromat 创建新 Scenario 并选择 Webhook&#34;&gt;&lt;/p&gt;
&lt;p&gt;进入创建 Scenario 的界面，我们首先点击中心的问号，选择 Webhooks &amp;gt; Custom Webhooks 作为我们 Scenario 的起点。之后我们配置 Webhook：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点击 Webhook 设置窗口中的 Add，在弹出的 Add a hook 界面将 Webhook 名称设置为 &lt;strong&gt;IFTTT weibo webhook&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;点击左下角的 Show advanced settings，在 Data structure 处添加抓取自微博的数据结构：点击 Add，在弹出的窗口中将数据结构名称命名为 &lt;strong&gt;Weibo data structure&lt;/strong&gt;。这就是我们从 IFTTT 获取到的微博博文的三个关键数据的存储方式（微博文本、微博链接和微博图片）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/8xmh1FfwK9SLRvy.png&#34; alt=&#34;配置 Webhook、添加 Data structure&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下面我们开始设置微博数据结构：
&lt;ul&gt;
&lt;li&gt;点击右侧 Generator，在弹出的窗口中将 Content type 选择为 &lt;strong&gt;Query String&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在下方 Sample Data 中填入：&lt;code&gt;text=weiboText&amp;amp;url=weiboUrl&amp;amp;image=imageUrl&lt;/code&gt;，点击保存之后，我们就得到了一个合适的 Data Structure&lt;/li&gt;
&lt;li&gt;可以看到，上面 Sample Data 实际上就是我们利用 IFTTT 获取到微博数据的一个传递，其中 &lt;code&gt;text&lt;/code&gt; 字段保存「微博文本内容：weiboText」、&lt;code&gt;url&lt;/code&gt; 字段保存「微博链接：weiboUrl」、&lt;code&gt;image&lt;/code&gt; 字段保存「微博图片：imageUrl」&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/9EwG8oaXptnMThs.png&#34; alt=&#34;配置微博 Data structure&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将上面步骤配置的内容全部保存，我们得到这样的一个界面：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/R86yFxQpsDWGP1o.png&#34; alt=&#34;Integromat Webhook API 地址&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上图里面我框出来的地方就是 Integromat 的 Webhook API 地址。接下来，将上图中的 API 地址复制，在后面添加上我们刚刚声明的数据结构的请求，并在浏览器中访问一下，让 Integromat 对收到的请求进行判断，自动确定数据结构的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要注意的是，我们需要让这一步中的 URL 跟我们 IFTTT 发送给 Integromat 的请求一致，也就是在刚刚复制的 Integromat 请求地址后面，需要正确的拼接上我们的请求数据，这里给出一个示范：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果我们的 Integromat Webhook API 地址为：&lt;code&gt;https://hook.integromat.com/{integromat_api_key}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们请求的微博文本内容为：&lt;code&gt;TestingMyWebhook&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们请求的微博原文链接为：&lt;code&gt;https://m.weibo.cn/detail/4444027372221130&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们请求的微博图片链接为：&lt;code&gt;https://wx4.sinaimg.cn/orj360/63e5c1e1ly1g9f2lmag8hj20k00qoac8.jpg&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么我们最终拼接出来的 URL 请求为（没有换行，换行方便阅读）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;https://hook.integromat.com/{integromat_api_key}
?text=TestingMyWebhook
&amp;amp;url=https://m.weibo.cn/detail/4444027372221130
&amp;amp;image=https://wx4.sinaimg.cn/orj360/63e5c1e1ly1g9f2lmag8hj20k00qoac8.jpg
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将上面的 URL 复制到浏览器中访问，加载完成之后，如果我们得到了正确的数据结构，那么 Integromat 那边会自动显示 Successfully Determined，同时浏览器中会显示 Accepted 字样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/yPjM2fTUav8ldwr.png&#34; alt=&#34;成功确定数据结构&#34;&gt;&lt;/p&gt;
&lt;p&gt;到这里，我们先将 Integromat 的全部配置保存妥当，将上面 Integromat 的 URL 请求保存，不要关闭标签页，我们继续准备 IFTTT 的配置项目。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;🐖 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果这里 Integromat 平台未提示 Successfully Determined，或浏览器中未显示 Accepted，那么说明 URL 请求拼接有问题，请再次尝试保证数据结构确定无误，否则会对接下来的配置造成很大影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;-ifttt--webhook-&#34;&gt;在 IFTTT 平台找到 Webhook 接口&lt;/h4&gt;
&lt;p&gt;在 IFTTT 平台，我们进入 &lt;a href=&#34;https://ifttt.com/maker_webhooks&#34;&gt;Webhook 的动作界面&lt;/a&gt;，点击右侧的 Documentation，不出意外的话，你会看到专属于你自己的 Webhook Key，我们在 Integromat 中最后就会向这个地址发出 HTTP 请求，传递相应的微博博文数据，触发正确的 IFTTT 动作。因此，请记下这一请求的具体方式，包括请求 URL 以及请求 body 格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nt&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/U7bolMJ13aZD45Y.png&#34; alt=&#34;Webhook Documentation&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们在刚刚对两个平台的配置的基础之上，对两个平台进行连接，实现自动化的微博 → Twitter 转发过程。&lt;/p&gt;
&lt;h3 id=&#34;ifttt--webhook-integromat&#34;&gt;IFTTT 触发 Webhook，调用 Integromat&lt;/h3&gt;
&lt;p&gt;首先，我们在 IFTTT 平台创建一个新的 Applet，作为检测到新微博的起始动作。IFTTT 在检测到我们发送一条新微博之后，会向 Integromat 发送一个 HTTP 请求，告知 Integromat 我们的新微博的文本消息、图片内容和原文链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/4Iry8JbMqHD97aY.png&#34; alt=&#34;This 选择 Sina Weibo 触发&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 IFTTT 上面，点击右上角 &lt;a href=&#34;https://ifttt.com/create&#34;&gt;头像 &amp;gt; Create&lt;/a&gt;，进入创建 Applet 的界面。在 This 处选择 Sina Weibo，选择 New post by you 的触发器。如果要求登录微博那么选择链接即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/29/9O6GfAsYrVbTtM7.png&#34; alt=&#34;That 选择 Webhook 服务&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 That 处选择 Webhooks，选择 Make a web request，之后进入配置 Webhook 的界面。&lt;strong&gt;我们在 URL 处填写刚刚 Integromat 的 Webhook API 地址（不包含测试用的拼接部分，即只填入 Integromat 显示的 URL），在 Method 处选择 POST，在 Content Type 处选择 &lt;code&gt;application/x-www-form-urlencode&lt;/code&gt;，最后在 Body 处填写：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;text={{Text}}&amp;amp;url={{WeiboURL}}&amp;amp;image={{PhotoURL}}
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/02/knthILgj7M1cuOd.png&#34; alt=&#34;填写 Webhook 请求地址，触发 Integromat 动作&#34;&gt;&lt;/p&gt;
&lt;p&gt;点击 Create action 保存动作，这样，我们 IFTTT 的起手触发动作就制作完成了。&lt;/p&gt;
&lt;h3 id=&#34;ifttt--twitter-&#34;&gt;IFTTT 自动发送 Twitter 动作&lt;/h3&gt;
&lt;p&gt;接下来，我们在 IFTTT 平台继续创建两个不同的 Applet，分别用来处理带图微博和纯文本微博的转发。我们和之前一样，选择 Create，配置 This 和 That。&lt;/p&gt;
&lt;p&gt;对带图微博：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This 处选择 Webhooks，选择 Receive a web request，并给 Event name 起名为 &lt;code&gt;image_weibo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;That 处选择 Twitter，选择 Post a tweet，并将 Tweet text 设置为：&lt;code&gt;{{Value1}} via Weibo: {{Value2}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对纯文本微博：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This 处选择 Webhooks，选择 Receive a web request，并给 Event name 起名为 &lt;code&gt;text_weibo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;That 处选择 Twitter，选择 Post a tweet with image，并将 Tweet text 设置为：&lt;code&gt;{{Value1}} via Weibo: {{Value2}}&lt;/code&gt;，将 Image URL 设置为：&lt;code&gt;{{Value3}}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;🍧 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里，我们将从 Integromat 中收到即将发送的推特的三个参数，分别为原微博的文本内容、原微博链接以及（如果有）原微博的图片。在 IFTTT 中，我们分别设置这三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{Value1}}&lt;/code&gt;：原微博文本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{Value2}}&lt;/code&gt;：原微博链接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{Value3}}&lt;/code&gt;：原微博图片（如果有）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的三个 Key 就是 &lt;code&gt;{{ ... }}&lt;/code&gt; 所包含的内容，这里的配置会和接下来 Integromat 的请求一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样，我们 IFTTT 平台的配置就基本完成了。接下来我们对 Integromat 的动作进行完善。&lt;/p&gt;
&lt;h3 id=&#34;integromat-&#34;&gt;Integromat 路由判断树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/02/6v5qX2zT1Hcde9n.png&#34; alt=&#34;Integromat 路由判断树&#34;&gt;&lt;/p&gt;
&lt;p&gt;在我们刚刚创建的 Scenario 里面，Webhook 后面，添加一个路由选择：Router。（点击右侧突出的半圆即可添加新的元素，搜索 Router，点击 Flow control 并选择 Router 即可添加。）&lt;/p&gt;
&lt;p&gt;在 Router 中第一条分支上面点击，选择设置 Filter，在 Label 处为分支起名为：ImageWeibo，用来专门处理带图片的微博。&lt;strong&gt;在 Condition 里配置 Image contains &lt;code&gt;http&lt;/code&gt; 的判断条件&lt;/strong&gt;，用来正确的调用合适的 IFTTT 动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/02/kHB45v3TtJxcnhC.png&#34; alt=&#34;第一条分支的 Filter 过滤器&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;🍳 注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在最初少数派的文章介绍之中，原作者用「Image exists」作为判断条件。经过我的调试发现：即使是并没有包含图片的纯文本微博，在 IFTTT 抓取微博信息并传到 Integromat 之后，Integromat 判断树并不能正确的判断这条微博没有图片，而是会自动触发默认路径，导致我们依旧发出一条带有「IFTTT 找不到图片」的推特。因此，这里我使用的判断条件为：「Image contains &lt;code&gt;http&lt;/code&gt;」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在分支末端点击问号，搜索 HTTP，选择 Make a request。之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 URL 中填入 IFTTT 带图微博转发的 Applet Webhook 请求地址：&lt;code&gt;https://maker.ifttt.com/trigger/image_weibo/with/key/{IFTTT API Key}&lt;/code&gt;（将 &lt;code&gt;{IFTTT API Key}&lt;/code&gt; 更换为上面在 IFTTT Webhook Documentation 中配置的 Key。）&lt;/li&gt;
&lt;li&gt;在下面的 Method 中选择 POST&lt;/li&gt;
&lt;li&gt;Body type 中选择 &lt;code&gt;application/x-www-form-urlencode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 Fields 中点击 Add item：
&lt;ul&gt;
&lt;li&gt;Key 填入 &lt;code&gt;value1&lt;/code&gt;，Value 选择 &lt;code&gt;text&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Key 填入 &lt;code&gt;value2&lt;/code&gt;，Value 选择 &lt;code&gt;url&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Key 填入 &lt;code&gt;value3&lt;/code&gt;，Value 选择 &lt;code&gt;image&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/02/A7Cam4tQzJBfu5b.png&#34; alt=&#34;触发 IFTTT 带图微博转发 Applet&#34;&gt;&lt;/p&gt;
&lt;p&gt;在第二条分支上面点击，选择设置 Filter 并填入 Label 为 PureTextWeibo，在 Condition 处设置筛选条件为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Image &lt;em&gt;Does not contain&lt;/em&gt; &lt;code&gt;http&lt;/code&gt; &lt;strong&gt;AND&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Text &lt;em&gt;Does not match pattern (case insensitive)&lt;/em&gt; &lt;code&gt;(Repost)|(转发微博)|(\/\/)|(轉發微博)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个判断条件进行「与」运算，保证满足两条内容才能触发本条规则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/02/T1cpRHlqawrdi84.png&#34; alt=&#34;第二条分支的 Filter 过滤器&#34;&gt;&lt;/p&gt;
&lt;p&gt;在分支末端点击问号，搜索 HTTP，选择 Make a request。之后：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 URL 中填入 IFTTT 纯文本微博转发的 Applet Webhook 请求地址：&lt;code&gt;https://maker.ifttt.com/trigger/text_weibo/with/key/{IFTTT API Key}&lt;/code&gt;（将 &lt;code&gt;{IFTTT API Key}&lt;/code&gt; 更换为上面在 IFTTT Webhook Documentation 中配置的 Key。）&lt;/li&gt;
&lt;li&gt;在下面的 Method 中选择 POST&lt;/li&gt;
&lt;li&gt;Body type 中选择 &lt;code&gt;application/x-www-form-urlencode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 Fields 中点击 Add item：
&lt;ul&gt;
&lt;li&gt;Key 填入 &lt;code&gt;value1&lt;/code&gt;，Value 选择 &lt;code&gt;text&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Key 填入 &lt;code&gt;value2&lt;/code&gt;，Value 选择 &lt;code&gt;url&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/02/h9GcBaOuexkiUSI.png&#34; alt=&#34;触发 IFTTT 纯文本微博转发 Applet&#34;&gt;&lt;/p&gt;
&lt;p&gt;到这里，保存 Scenario，我们基本配置任务就完成了。( •̀ ω •́ )y&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;最终的转发效果以及局限性&lt;/h2&gt;
&lt;p&gt;如果一些顺利，那么我们就应该可以直接让 IFTTT 和 Integromat 配合在云端默默监控我们的最新微博，并自动的根据合适的方式帮我们转发至 Twitter。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/12/07/F8Pgq2keAU3Sfw5.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是，这种转发方式还是有一定的限制，其中最为致命的实际上就是：IFTTT 只能捕获微博的第一张图片，多于一张的图片我们就只能将第一张图片转发到 Twitter。同时 Integromat 的同步次数也有一定的限制，每个月相当于最多能转发 500 条原创微博。不过这些对我来说还是足够的，如果有更多的需求，我推荐大家购买完整版的「奇点」微博客户端，能够自动每次发微博的同时发送推特，更为方便。这篇文章的介绍就到这里，感谢阅读。&lt;/p&gt;
</description>
            </item>
        
            <item>
                <title>Reverse Proxy | 反向代理是什么？</title>
                <link>https://blog.spencerwoo.com/2019/11/reverse-proxy/</link>
                <pubDate>Fri, 22 Nov 2019 21:14:00 +0800</pubDate>
                
                <guid>https://blog.spencerwoo.com/2019/11/reverse-proxy/</guid>
                <description>&lt;p&gt;&lt;a href=&#34;https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/&#34;&gt;Tiny Tiny RSS | 最速部署私有 RSS 服务器&lt;/a&gt; 这篇文章里面，我们提到了「利用 Nginx 作为反向代理」来为 Tiny Tiny RSS 服务加上 SSL 支持。事实上，我经常都能在各个和 Nginx、Apache Server 等相关文档里面看到「反向代理」这个术语。今天我们就来看看，到底什么是反向代理？「反向代理」的工作原理，以及我们都可以用「反向代理」来干什么？&lt;/p&gt;
&lt;h2 id=&#34;proxy&#34;&gt;Proxy：什么是代理？&lt;/h2&gt;
&lt;p&gt;首先，反向代理（Reverse Proxy）是一种代理（Proxy）服务。为了搞清楚「反向代理」，我们首先来说一说「代理 - Proxy」。&lt;/p&gt;
&lt;p&gt;相信阅读这篇文章的同学一定对 Proxy 这个名词不陌生，&lt;del&gt;Mainland China 互联网现状让大部分同学的计算机网络知识突飞猛进&lt;/del&gt;😂。简单来说，Proxy 服务器的主要功能就是在客户端 Client 和服务端 Server 之间搭建一个桥梁，从客户端访问服务端的网络流量、以及从服务端返回客户端的网络流量都会经由这一 Proxy 服务器的转发。&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/SX6GjARx5eKpfEI.png&#34; alt=&#34;功能示意&#34;&gt;&lt;/p&gt;
&lt;p&gt;为了方便表述，我们就叫我们的 Proxy 服务器：咕咕，一只鸽子。🐦&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;正向代理和反向代理&lt;/h2&gt;
&lt;h3 id=&#34;forward-proxy&#34;&gt;Forward Proxy：正向代理&lt;/h3&gt;
&lt;p&gt;飞鸽传书嘛，信鸽主要功能就是通风报信，我们这里的咕咕也不例外。咕咕在正常情况下是我们自己（客户端）的，也就意味着：咕咕会在 Client 前面等待送信。当 Client 准备发送一个请求的时候，咕咕会拿着这个请求，在公共互联网上面，将请求准确送达至对应的 Server。同理，Server 返回 response 给 Client，response 也会先被咕咕拿到，之后再转交给 Client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/agNBpxLzSoIAFhi.png&#34; alt=&#34;Forward Proxy 的工作原理&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面就是「正向代理」的基本工作流程，咕咕就是我们这个例子里面的正向代理服务器，负责转发和接受从 Client 发出或收到的网络请求。我们用正向代理（Forward Proxy），&lt;del&gt;除了大家人尽皆知的目的以外&lt;/del&gt;😂，还可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有效屏蔽广告、追踪脚本等有害请求。咕咕可以选择性的将 Server 发来的内容进行屏蔽，也就是：咕咕知道这次发来的是个广告，不给我们看也无妨大碍，那为了让我们浏览体验更加纯净，咕咕就非常体贴的丢掉了这一广告。爱了 ❤️ &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;有效的隐藏我们的身份。因为咕咕在你没有用到它的时候，可以并行的为其他同学传递请求。这时候，Server 是无从知道请求的真正来源的，只知道是由咕咕转手的，从而保证我们身份匿名性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;reverse-proxy&#34;&gt;Reverse Proxy：反向代理&lt;/h3&gt;
&lt;p&gt;那么反向代理是怎样工作的呢？在反向代理中，我们的咕咕现在由服务器 Server 养活（部署），也就是说，咕咕在服务器端通风报信。每个从 Client 经由互联网发过来的请求会先到达咕咕这里，咕咕再将每个请求分发给相应的服务器。反之亦然。这就是「反向代理」的基本工作原理，我们在这个例子里面的「咕咕」，就是我们的反向代理服务器。（Reverse Proxy Server）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/hUC5TGactx16AJM.png&#34; alt=&#34;Reverse Proxy 的工作原理&#34;&gt;&lt;/p&gt;
&lt;p&gt;为什么我们服务端也需要一个这样的咕咕呢？因为我们的咕咕不仅勤劳，还很坚强。要知道，不是所有的目标服务器都像我们咕咕那么坚强，目标服务器很多时候会因为直接收到的信件过多（收到过多的请求）而被淹没，甚至宕机。如果有咕咕的帮助，目标服务器就不会因为请求过多而无法处理，同时如果咕咕发现一个服务的请求太多，我们可以将这一服务增加多个服务器共同处理，咕咕这时候就可以将服务的请求进行分流，从而减轻单个服务器的处理负担。&lt;strong&gt;这也就是「反向代理」在「负载均衡」方面的应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上，反向代理服务器有更多的应用，我们接下来就具体说一说我在服务器上面都利用 Nginx 反向代理服务器做了哪些有用的事情。&lt;/p&gt;
&lt;h2 id=&#34;nginx-&#34;&gt;Nginx 反向代理的实际应用&lt;/h2&gt;
&lt;p&gt;在我的（&lt;a href=&#34;https://blog.tenkeyseven.com&#34;&gt;@TenkeySeven&lt;/a&gt; 的）服务器上面，有这样的几个服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tt-rss.org/&#34;&gt;Tiny Tiny RSS 服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/netdata/netdata&#34;&gt;Netdata 服务器监控服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Nginx 直接 serve 的一个默认静态页面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事实上，这三个服务都运行在这样的一个服务器上面，但是绑定了不同的域名。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiny Tiny RSS 服务对应域名：&lt;a href=&#34;https://ttrss.tenkeyseven.com&#34;&gt;https://ttrss.tenkeyseven.com&lt;/a&gt;（需要登录）&lt;/li&gt;
&lt;li&gt;Netdata 服务对应域名：&lt;a href=&#34;https://stats.tenkeyseven.com&#34;&gt;https://stats.tenkeyseven.com&lt;/a&gt;（可以公开访问）&lt;/li&gt;
&lt;li&gt;Nginx 测试静态页面对应域名：&lt;a href=&#34;https://tenkeyseven.com&#34;&gt;https://tenkeyseven.com&lt;/a&gt;（可以公开访问）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们连接到服务器上面，执行下面的命令来查看端口占用情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo netstat -tulpn &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; grep LISTEN
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/XrHv2C5xA8liF3Z.png&#34; alt=&#34;端口占用情况&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过查看端口占用情况，我们可以非常清晰的看到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiny Tiny RSS 运行于 Docker 容器中，对外的 exposed 端口是 181&lt;/li&gt;
&lt;li&gt;Netdata 前端服务直接监听的端口是 19999&lt;/li&gt;
&lt;li&gt;Nginx 默认 serve 的静态页面直接监听 80 端口（HTTP）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.tenkeyseven.com&#34;&gt;@TenkeySeven&lt;/a&gt; 将主域名和上面提到的两个子域名的 DNS 解析均设置为我们的服务器，因此，当我们访问上面任意一个域名的时候，请求均直接发给服务器上面运行的 Nginx 反向代理服务。&lt;/p&gt;
&lt;p&gt;对 Nginx 来说，只需要识别这些域名对应的请求应该转发给具体哪个服务，就可以让请求被正确处理，这样也就实现了我们多个域名对应一个服务器上的多个服务的需求。&lt;/p&gt;
&lt;p&gt;Nginx 全部功能均由配置文件 &lt;code&gt;nginx.conf&lt;/code&gt; 来设置，这一配置文件通常位于 &lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;，我们仔细看一下 Nginx 的配置文件。&lt;/p&gt;
&lt;h3 id=&#34;-upstream-&#34;&gt;对 upstream 服务器的定义&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/X4Dzh9fBL8NeRGa.png&#34; alt=&#34;对 upstream 服务器的声明&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先，我们在 Nginx 的 &lt;code&gt;http&lt;/code&gt; 项目下，定义了我们可能需要用到的 upstream 服务器。比如，对 Tiny Tiny RSS 来说，就是 181 端口的服务，用下面的语法进行声明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span class=&#34;k&#34;&gt;upstream&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;ttrssdev&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127.0.0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;181&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kn&#34;&gt;keepalive&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样，下面 &lt;code&gt;ttrss.tenkeyseven.com&lt;/code&gt; 域名的 Proxy 转发规则就可以直接用 &lt;code&gt;http://ttrssdev&lt;/code&gt; 的格式进行声明了。&lt;/p&gt;
&lt;h3 id=&#34;-web-root-&#34;&gt;默认 Web Root 的定义&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/6jpCBPVJNc9SQIY.png&#34; alt=&#34;默认访问 Web Root 的配置&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以发现，当我们服务并不绑定任何上游服务器，而是直接由 Nginx 来提供服务的时候，Nginx 可以直接 serve 一个目标路径里面的 HTML 文件，比如这里的 &lt;code&gt;/usr/share/nginx/html&lt;/code&gt;。此时，直接访问默认主域名 &lt;code&gt;tenkeyseven.com&lt;/code&gt;，我们就能直接看到一个默认的静态网页。具体来说，Nginx 就是下面这部分内容的配置，知道当请求匹配到 &lt;code&gt;server_name&lt;/code&gt; 定义的域名时，serve &lt;code&gt;root&lt;/code&gt; 处定义的 HTML 静态网站。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kn&#34;&gt;server_name&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;tenkeyseven.com&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# managed by Certbot
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       &lt;span class=&#34;kn&#34;&gt;root&lt;/span&gt;         &lt;span class=&#34;s&#34;&gt;/usr/share/nginx/html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
       &lt;span class=&#34;c1&#34;&gt;# ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;proxy-&#34;&gt;Proxy 转发规则的定义&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/yYojgkwLaAUfGM4.png&#34; alt=&#34;反向代理 Tiny Tiny RSS 转发规则的定义&#34;&gt;&lt;/p&gt;
&lt;p&gt;当我们需要让 Nginx 反向代理转发我们的请求至 upstream 服务的时候，就是类似这样的配置。此时，当请求匹配到 &lt;code&gt;server_name&lt;/code&gt; 定义的 &lt;code&gt;ttrss.tenkeyseven.com&lt;/code&gt; 时，Nginx 不 serve &lt;code&gt;root&lt;/code&gt; 处定义的页面，而是在 &lt;code&gt;location / { ... }&lt;/code&gt; 处找到 &lt;code&gt;proxy_pass&lt;/code&gt; 的定义，将请求对应的转发到目标服务那里。可以看到，这里我们直接声明了 &lt;code&gt;proxy_pass http://ttrssdev;&lt;/code&gt;，于是，当我们访问 &lt;code&gt;https://ttrss.tenkeyseven.com&lt;/code&gt; 的时候，Nginx 反向代理服务会直接将请求转发至我们部署的 Tiny Tiny RSS 服务，在服务器上就是 &lt;code&gt;localhost:181&lt;/code&gt; 的服务。&lt;/p&gt;
&lt;p&gt;Nginx 反向代理具体的配置如下 &lt;code&gt;location / { ... }&lt;/code&gt; 里面的配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-nginx&#34; data-lang=&#34;nginx&#34;&gt;&lt;span class=&#34;k&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kn&#34;&gt;server_name&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;ttrss.tenkeyseven.com&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# managed by Certbot
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;# root         /usr/share/nginx/html;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
       &lt;span class=&#34;c1&#34;&gt;# Load configuration files for the default server block.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       &lt;span class=&#34;kn&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/etc/nginx/default.d/*.conf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

       &lt;span class=&#34;kn&#34;&gt;location&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_redirect&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;off&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_pass&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;http://ttrssdev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

           &lt;span class=&#34;kn&#34;&gt;proxy_set_header&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;Host&lt;/span&gt;                &lt;span class=&#34;nv&#34;&gt;$http_host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_set_header&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;X-Real-IP&lt;/span&gt;           &lt;span class=&#34;nv&#34;&gt;$remote_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_set_header&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;X-Forwarded-Ssl&lt;/span&gt;     &lt;span class=&#34;no&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_set_header&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;X-Forwarded-For&lt;/span&gt;     &lt;span class=&#34;nv&#34;&gt;$proxy_add_x_forwarded_for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_set_header&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;X-Forwarded-Proto&lt;/span&gt;   &lt;span class=&#34;nv&#34;&gt;$scheme&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_set_header&lt;/span&gt;  &lt;span class=&#34;s&#34;&gt;X-Frame-Options&lt;/span&gt;     &lt;span class=&#34;s&#34;&gt;SAMEORIGIN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

           &lt;span class=&#34;kn&#34;&gt;client_max_body_size&lt;/span&gt;        &lt;span class=&#34;mi&#34;&gt;100m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;client_body_buffer_size&lt;/span&gt;     &lt;span class=&#34;mi&#34;&gt;128k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

           &lt;span class=&#34;kn&#34;&gt;proxy_buffer_size&lt;/span&gt;           &lt;span class=&#34;mi&#34;&gt;4k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_buffers&lt;/span&gt;               &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_busy_buffers_size&lt;/span&gt;     &lt;span class=&#34;mi&#34;&gt;64k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
           &lt;span class=&#34;kn&#34;&gt;proxy_temp_file_write_size&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;64k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    
    &lt;span class=&#34;c1&#34;&gt;# ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;事实上，这部分的配置非常简单。得益于 Let&#39;s Encrypt 的存在，我们可以利用 Certbot 在签署每个域名的 SSL 证书时，自动生成对应服务的转发配置。因此，事实上我们只需要声明前面介绍的 upstream 服务，并在 Certbot 生成的对应域名下的 location 子项处将服务器对应到反向代理的配置项处即可。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;最后，我们可以看到，经过这样的配置，我们从外界互联网访问我们服务器的请求，就被 Nginx 反向代理分别导向了对应的服务器，从而实现了多个域名对应多个服务，并部署在同一个服务器上面的功能。同时，Nginx 反向代理服务统一帮我们管理了 SSL 证书的签署，因此无论是从外界来访问我们服务器的请求，还是我们服务器里面某个服务返回给外界的请求，都是经过加密的 HTTPS 请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/23/2zKHFZmQXShLRAC.png&#34; alt=&#34;Nginx 反向代理在上文中的功能&#34;&gt;&lt;/p&gt;
&lt;p&gt;Nginx 反向代理服务器还有更多的功能，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前文提到的负载均衡（Load balance）&lt;/li&gt;
&lt;li&gt;用反向代理来作为 CDN，cache 一部分资源，加快访问速度&lt;/li&gt;
&lt;li&gt;在请求到达目标服务器之前，反向代理服务器事先过滤掉一部分恶意请求，保证提供服务的目标服务器的稳定工作&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;抛砖引玉，感谢阅读。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/&#34;&gt;What Is A Reverse Proxy? | Proxy Servers Explained - Cloudflare&lt;/a&gt; &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=KBXTnrD_Zs4&#34;&gt;Block EVERY Online Ad with THIS / Linus Tech Tips&lt;/a&gt; &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
            </item>
        
            <item>
                <title>Tiny Tiny RSS | 最速部署私有 RSS 服务器</title>
                <link>https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/</link>
                <pubDate>Mon, 18 Nov 2019 12:23:07 +0800</pubDate>
                
                <guid>https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/</guid>
                <description>&lt;p&gt;9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～&lt;/p&gt;
&lt;h2 id=&#34;rss&#34;&gt;RSS&lt;/h2&gt;
&lt;p&gt;首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。&lt;/p&gt;
&lt;p&gt;对于第一次接触 RSS 的同学，推荐大家阅读：&lt;a href=&#34;https://sspai.com/post/56391&#34;&gt;高效获取信息，你需要这份 RSS 入门指南&lt;/a&gt;，进行扫盲。&lt;/p&gt;
&lt;p&gt;市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！&lt;/p&gt;
&lt;h2 id=&#34;tiny-tiny-rss-&#34;&gt;Tiny Tiny RSS 的搭建&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/19/aCty2KspU5f1gHr.jpg&#34; alt=&#34;使用 Feedly 主题的 Tiny Tiny RSS 服务端&#34;&gt;&lt;/p&gt;
&lt;p&gt;Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 &lt;code&gt;certbot&lt;/code&gt;，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）&lt;/p&gt;
&lt;p&gt;在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐和放宽，我们立刻开始。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;在开始之前，首先我们需要准备一个位于公网的服务器，以及一个可以通过 SSH 连接到服务器上的本地设备。这里我使用我同（bai）学（piao）的已经备案的阿里云服务器作为运行 Tiny Tiny RSS 的服务器，并使用 iPad 和 Blink Shell（一个支持 SSH 协议的 iOS 终端 App）作为我的操作设备。Blink Shell 是 iPad 上面最好用的 SSH/Mosh 工具，推荐大家使用。我们在 Blink Shell 中配置好服务器私钥，通过 SSH 登录服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/19/iyk8KrUBYzodPqS.jpg&#34; alt=&#34;利用 Blink Shell 登录至服务器&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-docker--tiny-tiny-rss&#34;&gt;利用 Docker 部署 Tiny Tiny RSS&lt;/h2&gt;
&lt;h3 id=&#34;-docker&#34;&gt;安装 Docker&lt;/h3&gt;
&lt;p&gt;Docker 是非常优秀的虚拟化容器，借助于 Docker 我们可以方便的部署 Tiny Tiny RSS，首先我们在服务器上安装 Docker 本体。在服务器上面执行下面命令来安装 Docker：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;curl -fsSL https://get.docker.com/ &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; sh
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后启动 Docker 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo systemctl start docker
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后，我们检查一下 Docker 是否启动成功。我们执行命令：&lt;code&gt;sudo systemctl status docker&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/L6VicoJy8OCBpxq.jpg&#34; alt=&#34;检查 Docker 服务状态&#34;&gt;&lt;/p&gt;
&lt;p&gt;看到如上的输出，说明我们 Docker 服务启动成功。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考资料：&lt;a href=&#34;https://docs.docker.com/install/linux/docker-ce/centos/&#34;&gt;Get Docker Engine - Community for CentOS | Docker Documentation&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;-docker-compose&#34;&gt;安装 docker-compose&lt;/h3&gt;
&lt;p&gt;接下来我们安装 &lt;code&gt;docker-compose&lt;/code&gt;：一个管理和启动多个 Docker 容器的工具。由于 Tiny Tiny RSS 依赖有 PostgreSQL 的数据库服务以及 &lt;a href=&#34;https://github.com/HenryQW/mercury_fulltext&#34;&gt;mercury_fulltext&lt;/a&gt; 的全文抓取服务等等，这些服务我们都借助于 Docker 部署，因此利用 &lt;code&gt;docker-compose&lt;/code&gt; 就会大大降低我们的部署难度。&lt;/p&gt;
&lt;p&gt;我们继续，在服务器上面执行下面的命令来安装 &lt;code&gt;docker-compose&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;curl -L https://github.com/docker/compose/releases/download/1.25.0/docker-compose-&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;uname -s&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;-&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;uname -m&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt; -o /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;之后给予安装好的 &lt;code&gt;docker-compose&lt;/code&gt; 可执行权限：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;em&gt;参考资料：&lt;a href=&#34;https://docs.docker.com/compose/install/&#34;&gt;Install Docker Compose | Docker Documentation&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;最后我们运行 &lt;code&gt;docker-compose --version&lt;/code&gt; 来检查安装是否成功。如果有如下输出，说明我们的 &lt;code&gt;docker-compose&lt;/code&gt; 安装成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/6j3QgG1FszTPp5Y.jpg&#34; alt=&#34;检查 docker-compose 安装情况&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-tiny-tiny-rss-&#34;&gt;安装 Tiny Tiny RSS 及其周边服务&lt;/h3&gt;
&lt;p&gt;准备工作已经全部完成，接下来我们下载由 Awesome-TTRSS 配置的 Tiny Tiny RSS 服务的 docker-compose 配置文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 创建 ttrss 目录并进入&lt;/span&gt;
mkdir ttrss &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; ttrss

&lt;span class=&#34;c1&#34;&gt;# 利用 curl 下载 ttrss 的 docker-compose 配置文件至服务器&lt;/span&gt;
curl -fLo docker-compose.yml https://github.com/HenryQW/Awesome-TTRSS/raw/master/docker-compose.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;修改 docker-compose.yml 里面的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/sn4MP8uvb3WIzDt.png&#34; alt=&#34;修改 docker-compose 配置文件&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在配置文件的第 7 行和第 23 行，将 PostgreSQL 数据库的默认密码进行修改。暴露在公网的数据库使用默认密码非常危险。&lt;/li&gt;
&lt;li&gt;在配置文件的第 18 行，将 Tiny Tiny RSS 服务的部署网址修改。比如我的部署网址是 &lt;code&gt;https://ttrss.tenkeyseven.com/&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;注意，如果你的部署 URL 包含端口（比如默认部署端口为 181 端口），那么这里的 URL 也需要加上端口号，格式为 &lt;code&gt;{网址}:{端口}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不过不必担心，如果你这里的 URL 配置不正确，那么访问 Tiny Tiny RSS 的时候，Tiny Tiny RSS 会提醒你修改这里的值为正确的 URL，按照提醒进行配置即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后，我们保存配置文件，启动 Tiny Tiny RSS 服务。在刚刚的 &lt;code&gt;ttrss&lt;/code&gt; 目录下执行：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;等待脚本执行完成，如果一切没有问题，那么接下来输入 &lt;code&gt;docker ps&lt;/code&gt;，我们应该看到类似下面的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/AxTdoa7YJCgI5i4.jpg&#34; alt=&#34;查看正在运行的 Docker 容器&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面内容表示我们开启了四个 Docker 容器，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tiny Tiny RSS 本身，监听端口为 &lt;code&gt;0.0.0.0:181 -&amp;gt; 80&lt;/code&gt;，同时暴露给外网&lt;/li&gt;
&lt;li&gt;PostgreSQL 数据库，仅供内部使用&lt;/li&gt;
&lt;li&gt;Mercury 全文抓取服务，仅供内部使用&lt;/li&gt;
&lt;li&gt;OpenCC 简体、繁体中文转换服务，仅供内部使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果发现问题，修改 docker-compose 配置文件后，需要执行下面的命令重启 Docker 容器们：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 关闭 Docker 容器们&lt;/span&gt;
docker-compose down

&lt;span class=&#34;c1&#34;&gt;# 删除已停止的 Docker 容器&lt;/span&gt;
docker-compose rm

&lt;span class=&#34;c1&#34;&gt;# ……&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 修改 docker-compose 配置文件&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# ……&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 再次开启 Docker 服务&lt;/span&gt;
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;-nginx--docker-&#34;&gt;安装 Nginx 作为 Docker 容器的反向代理&lt;/h2&gt;
&lt;p&gt;事实上，到上一步，如果我们访问 &lt;code&gt;{服务器 IP}:181&lt;/code&gt;，应该可以直接看到 Tiny Tiny RSS 的 Web 前端，但是 Tiny Tiny RSS 并不能直接配置 SSL 证书，也就没法添加 HTTPS 支持。我们利用 Nginx 作为反向代理服务器，即可方便的给 Tiny Tiny RSS 单独绑定一个我们希望的域名，并利用 Let’s Encrypt 来部署 HTTPS。&lt;/p&gt;
&lt;h3 id=&#34;-nginx&#34;&gt;安装 Nginx&lt;/h3&gt;
&lt;p&gt;首先我们来安装 Nginx，以 CentOS 为例，我们直接执行下面命令即可：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo yum install nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;之后开启 Nginx 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo systemctl start nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;检查 Nginx 是否启动成功：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/gakiyznx5NhXT16.jpg&#34; alt=&#34;检查 Nginx 运行状态&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-ssl--https&#34;&gt;签署 SSL 证书，部署 HTTPS&lt;/h3&gt;
&lt;p&gt;之后，我们利用 Let’s Encrypt 提供的 &lt;code&gt;certbot&lt;/code&gt; 直接为 Nginx 配置 SSL 证书。首先，我们执行下面的命令安装 &lt;code&gt;certbot&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo yum install certbot python2-certbot-nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然后运行 &lt;code&gt;certbot&lt;/code&gt; 来签署 SSL 证书并自动配置 Nginx 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo certbot --nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;em&gt;参考资料：&lt;a href=&#34;https://certbot.eff.org/lets-encrypt/centosrhel7-nginx&#34;&gt;Certbot | Nginx on CentOS/RHEL 7&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这里，certbot 会要求我们输入我们希望签署 SSL 证书的域名，我们选择为 Tiny Tiny RSS 分配的域名（比如我的就是 &lt;code&gt;ttrss.tenkeyseven.com&lt;/code&gt;）即可。另外，如果 certbot 询问是否需要将访问该网址的全部流量重定向至 HTTPS，那么选择「是」即可。我们等待脚本执行签署任务完毕，然后重启 Nginx 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时我们如果直接访问这一域名，应该就可以看到带有 HTTPS 的 Nginx 默认网站：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/jWwRplvBD8oOczJ.jpg&#34; alt=&#34;HTTPS 配置成功的 Nginx 默认网站&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们修改 Nginx 的配置文件，配置 Nginx 反向代理，将访问 &lt;code&gt;https://ttrss.tenkeyseven.com&lt;/code&gt; 的请求指向我们刚刚部署好的 Tiny Tiny RSS 服务，对服务器来说，也就是 &lt;code&gt;127.0.0.1:181&lt;/code&gt; 这一地址。（如果你没有更改 Tiny Tiny RSS 的端口号的话。）&lt;/p&gt;
&lt;p&gt;Nginx 的配置文件位于 &lt;code&gt;/etc/nginx/nginx.conf&lt;/code&gt;，我们打开这一文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/J9yaSejPN1iLnkO.png&#34; alt=&#34;Nginx 配置文件&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;http&lt;/code&gt; 项下，&lt;code&gt;server&lt;/code&gt; 项前定义 &lt;code&gt;upstream&lt;/code&gt; 服务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;upstream ttrssdev {
    server 127.0.0.1:181;
    keepalive 64;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;
 ![Nginx upstream 服务声明](https://i.loli.net/2019/11/20/XLAlTsegadr5cPE.jpg)

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在刚刚 &lt;code&gt;certbot&lt;/code&gt; 为我们生成好的响应域名 &lt;code&gt;server&lt;/code&gt; 项下，注释掉第一行定义 &lt;code&gt;root&lt;/code&gt; 的内容，并将 &lt;code&gt;location /&lt;/code&gt; 项修改为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;location / {
    proxy_redirect off;
    proxy_pass http://ttrssdev;

    proxy_set_header  Host                $http_host;
    proxy_set_header  X-Real-IP           $remote_addr;
    proxy_set_header  X-Forwarded-Ssl     on;
    proxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto   $scheme;
    proxy_set_header  X-Frame-Options     SAMEORIGIN;

    client_max_body_size        100m;
    client_body_buffer_size     128k;

    proxy_buffer_size           4k;
    proxy_buffers               4 32k;
    proxy_busy_buffers_size     64k;
    proxy_temp_file_write_size  64k;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;
 ![Nginx 配置文件：反向代理配置](https://i.loli.net/2019/11/20/LVXAFOfywRB2inr.jpg)

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，我们再次执行 &lt;code&gt;sudo systemctl restart nginx&lt;/code&gt; 重启 Nginx 服务，一切顺利的话，我们就可以通过我们刚刚签署 SSL 证书的域名访问我们部署好的 Tiny Tiny RSS 服务了！鼓掌 👏&lt;/p&gt;
&lt;p&gt;Tiny Tiny RSS 的默认管理员账户密码是 admin 和 password，请在第一时间进行修改。&lt;/p&gt;
&lt;h2 id=&#34;-tiny-tiny-rss&#34;&gt;配置 Tiny Tiny RSS&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/20/cis6yUboY2KStEn.jpg&#34; alt=&#34;Tiny Tiny RSS 配置、主题&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果上面步骤没有问题的话，我们在服务器上面所部署的 Tiny Tiny RSS 本身就已经包含了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mercury 全文提取服务（默认未开启）&lt;/li&gt;
&lt;li&gt;OpenCC 繁简自动转换服务（默认未开启）&lt;/li&gt;
&lt;li&gt;Fever 格式输出插件（默认已开启，用来和 Reeder 等客户端进行连接）&lt;/li&gt;
&lt;li&gt;包括 Feedly、RSSHub 在内的多款主题&lt;/li&gt;
&lt;li&gt;等等……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们不需要多余的配置，开箱即可使用上面的主题和插件，根本不需要操心其他服务的部署和安装。我们登录自己的 Tiny Tiny RSS，在右上角「设置→ 插件」中即可启用上述插件，在「设置 → 主题」处就可以更改我们部署的 Tiny Tiny RSS 所用的主题。这些插件和主题在 &lt;a href=&#34;https://sspai.com/post/41302&#34;&gt;如何搭建属于自己的 RSS 服务，高效精准获取信息&lt;/a&gt; 中已经介绍了使用方法，这里我就不再赘述了。&lt;/p&gt;
&lt;p&gt;如果有同学对上面的配置还有问题，请直接参考 &lt;a href=&#34;https://ttrss.henry.wang/zh/#%E6%8F%92%E4%BB%B6&#34;&gt;Awesome TTRSS 的官方文档：🐋 Awesome TTRSS | 插件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;Tiny Tiny RSS 的配置到这里就基本结束了，我相信你通过上面的配置一定已经在自己的服务器上部署成功了 Tiny Tiny RSS 服务，并为它添加了域名和 HTTPS 的支持。另外，Tiny Tiny RSS 还自带了账号系统，可以邀请其他志同道合的朋友们一起使用我们自己部署的 Tiny Tiny RSS。感谢阅读。&lt;/p&gt;
&lt;p&gt;📖 关联阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E&#34;&gt;🐋 Awesome TTRSS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sspai.com/post/56893&#34;&gt;少数派 sspai - Docker 的入门「指北」&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sspai.com/post/41302&#34;&gt;少数派 sspai - 如何搭建属于自己的 RSS 服务，高效精准获取信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            </item>
        
            <item>
                <title>Working Copy &#43; iA Writer：第二次尝试从我的 iPad 上面更新博客</title>
                <link>https://blog.spencerwoo.com/2019/11/update-from-ipad-iawriter/</link>
                <pubDate>Thu, 14 Nov 2019 06:24:53 +0000</pubDate>
                
                <guid>https://blog.spencerwoo.com/2019/11/update-from-ipad-iawriter/</guid>
                <description>&lt;p&gt;之前，我就曾经介绍过我是如何利用 iPad 对部署在 GitHub 上面的静态博客进行更新的。这篇文章即使到现在也有一定的借鉴意义，文章归档于：&lt;a href=&#34;https://archive.spencerwoo.com/posts/2019/06/09/from-my-ipad.html&#34;&gt;使用 Working Copy 在 iPad 上面更新博客 | 一次随缘的更新&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在，我重新部署了我的静态博客，利用 Hugo 进行构建。宣称全球最快的静态网站渲染引擎 —— Hugo 着实让我博客的编译和部署过程快人一步。借助于方便的 Netlify，只要配置好 CI 的编译命令和环境变量，我们就只需要专注于博客本身的撰写，而不必对博客其他属性进行过多的担心。这样的部署方法，让 iPad 都可以直接发表博文。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;为什么我又换回了静态博客？Listed 确实不错，但是我在给与之配套的笔记应用 Standard Notes 充值一年会员之后，发现 Standard Notes 真的不行。不论是应用本身的响应还是界面的设计，Standard Notes 都和 Bear 等一众笔记应用相距甚远。Listed 博客需要会员才能自定义域名，并且 Listed 本身也没有评论系统，只有一个类似留言板的 Guestbook，难过。&lt;/p&gt;
&lt;p&gt;另外，我还专门问了问开发者为什么 Listed 不支持评论：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/14/Cm4Lc78TPbZrkBe.png&#34; alt=&#34;和 Listed/Standard Notes 作者的交流&#34;&gt;&lt;/p&gt;
&lt;p&gt;// 我猜是开发者被垃圾评论骂怕了 😂&lt;/p&gt;
&lt;p&gt;就这样，Hugo 就变成了目前我的博客部署引擎首选。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;设备和工具&lt;/h2&gt;
&lt;p&gt;更新博客我试用了下面的设备：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;iPad Air (3rd Gen)&lt;/li&gt;
&lt;li&gt;Logitech K380：键盘&lt;/li&gt;
&lt;li&gt;Logitech M558：鼠标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 iPad 上面，我尝试使用 iA Writer 来编辑 Markdown 文档，利用 Working Copy 来更新 GitHub 仓库。由于 Working Copy 支持 &lt;strong&gt;Edit in place&lt;/strong&gt;，因此我们在 iA Writer 中可以导入 Working Copy 的某个文件夹（比如博文文件夹 &lt;code&gt;posts&lt;/code&gt;），从而直接编辑其中的 Markdown 文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/14/jIKmWkgZ1nGwORq.png&#34; alt=&#34;在 iA Writer 中直接编辑 Working Copy 文件&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;更新流程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;利用 Working Copy 将博客源文件克隆至 iPad 上面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/14/cDnlHYPjMryvq3V.png&#34; alt=&#34;Working Copy 上面克隆仓库&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 iA Writer 打开 Working Copy 中的博客 &lt;code&gt;posts&lt;/code&gt; 文件夹&lt;/li&gt;
&lt;li&gt;在 iA Writer 中创建新文章、编辑旧博客文章&lt;/li&gt;
&lt;li&gt;在 iA Writer 中通过快捷键 &lt;code&gt;Command + R&lt;/code&gt; 直接预览文章&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/13/B4Xb32uxqg9cyaZ.png&#34; alt=&#34;iA Writer 编辑文章&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Working Copy 中通过 Git 直接将博客同步至 GitHub&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;iPad 胜在方便，不需要过多的配置即可直接撰写文章。爱了，❤️。&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;另外&lt;/h2&gt;
&lt;p&gt;除了上面的方法，Forestry.io 也是一个可以的选择。Forestry.io 是一个极度完善的静态博客 CMS 统一管理平台，支持 Hugo、VuePress、Gatsby 等诸多博客引擎。利用 Forestry 在线网页版本的后台管理，我们甚至可以直接的撰写文章内容，并在 Forestry 服务器上面渲染文章并预览。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/11/14/XTa63nLopB2KQAR.png&#34; alt=&#34;Forestry 的文章编辑界面&#34;&gt;&lt;/p&gt;
&lt;p&gt;Forestry 虽然好用，但是 Forestry 在 iPad 上面的编辑体验并不太好，因为相对小的屏幕，Forestry 的文章编辑界面相当狭窄，令人遗憾。&lt;/p&gt;
&lt;p&gt;总之，Working Copy 是 iPad 的最佳搭档，而 iA Writer 是 iPad 上面最纯粹的 Markdown 编辑器。这二者结合，确实能让我随时随地发布博客。爱了！❤️&lt;/p&gt;
</description>
            </item>
        
            <item>
                <title>Batch Git Pull：分享一个维护多个 Git 仓库的小脚本</title>
                <link>https://blog.spencerwoo.com/2019/11/batch-git-pull/</link>
                <pubDate>Wed, 13 Nov 2019 03:29:53 +0000</pubDate>
                
                <guid>https://blog.spencerwoo.com/2019/11/batch-git-pull/</guid>
                <description>&lt;p&gt;不废话，放脚本：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;find . -maxdepth &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; -name .git -type d &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; rev &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; cut -c 6- &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; rev &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; xargs -I &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; git -C &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; pull
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;更为方便的，直接将这部分加入你的 &lt;code&gt;.zshrc&lt;/code&gt; 或者 &lt;code&gt;.bash_profile&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;nb&#34;&gt;alias&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;gpall&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;find . -maxdepth 3 -name .git -type d | rev | cut -c 6- | rev | xargs -I {} git -C {} pull&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;之后，直接执行 &lt;code&gt;gpall&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;好了，我们进入正题。&lt;/p&gt;
&lt;h2 id=&#34;-git-&#34;&gt;维护多个 Git 仓库的需求&lt;/h2&gt;
&lt;p&gt;维护多个 Git 仓库不容易。我在我存放 GitHub 仓库的目录下运行了一下 &lt;code&gt;tree&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── AIP_BackEnd
├── Evaluation_BackEnd
| ... ...
├── SchoolProjects
│   ├── Distance-Vector-Algorithm
│   ├── cartoonize-images
| ... ...
│   ├── zanpress-blog
│   └── zanpress-diagram
| ... ...
└── wechat-format

103 directories
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;103 个目录……我自己 &lt;code&gt;Documents/GitHub&lt;/code&gt; 文件夹下就有这么多 Git 仓库，一个一个去更新真的很费事情。如何批量更新 GitHub 本地仓库呢？其实就是一个遍历目录，对匹配到的 Git 仓库在其当前分支下执行 &lt;code&gt;git pull&lt;/code&gt; 的需求嘛，很简单。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;解决方法&lt;/h2&gt;
&lt;p&gt;在 Medium 上面，我找到了一个相当优雅的脚本。前面这个脚本已经分享给各位了，我们重新看一下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;find . -maxdepth &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; -name .git -type d &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; rev &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; cut -c 6- &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; rev &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; xargs -I &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; git -C &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; pull
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以发现，这一长串命令，事实上就是前面的命令执行结果通过「管道」输出至后面的命令作为输入，也就是命令中 &lt;code&gt;|&lt;/code&gt; 的功能。我们一段一段看一下这个命令具体都干了什么。&lt;/p&gt;
&lt;h3 id=&#34;-find--git-&#34;&gt;用 &lt;code&gt;find&lt;/code&gt; 搜索目录下全部 &lt;code&gt;.git/&lt;/code&gt; 文件夹&lt;/h3&gt;
&lt;p&gt;每个 Git 文件夹里面一定有 &lt;code&gt;.git&lt;/code&gt; 的目录，我们只需要找到 &lt;code&gt;.git&lt;/code&gt; 文件夹既可以找到 Git 目录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;find . -maxdepth &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt; -name .git -type d
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里，我们就使用了 &lt;code&gt;find&lt;/code&gt; 的命令，详见：&lt;a href=&#34;https://www.gnu.org/software/findutils/manual/html_mono/find.html&#34;&gt;GNU - Finding Files&lt;/a&gt;。我们将命令分解来看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 表示匹配命令执行路径下的全部文件与文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-maxdepth 3&lt;/code&gt; 表示向下搜索最多三层级目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-name .git&lt;/code&gt; 就是搜索名称为 &lt;code&gt;.git&lt;/code&gt; 的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-type d&lt;/code&gt; 则指明了我们搜索的范畴：Directories（目录）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/10/29/IVMEzwDqGpXK8me.png&#34; alt=&#34;搜索 .git 文件夹&#34;&gt;&lt;/p&gt;
&lt;p&gt;一目了然，我们下面就这样对每个命令进行分解和解释。&lt;/p&gt;
&lt;h3 id=&#34;-git--1&#34;&gt;裁剪出我们要的 &lt;code&gt;.git&lt;/code&gt; 文件夹所在路径&lt;/h3&gt;
&lt;p&gt;上面我们解析出来的路径，每个路径后面都包含一个 &lt;code&gt;.git&lt;/code&gt;，我们需要统一将这个 &lt;code&gt;.git&lt;/code&gt; 从字符串中删掉，这样才能一起对给定目录执行 &lt;code&gt;git pull&lt;/code&gt;。第二步我们进行目录的裁剪。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;... &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; rev &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; cut -c 6- &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; rev &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; ...
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以发现，这里我们有三部分命令。我们依次对命令进行解析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;rev&lt;/code&gt;：首先对搜索到的目录（字符串）进行反转&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cut -c 6-&lt;/code&gt;：我们利用 &lt;code&gt;cut&lt;/code&gt; 工具将路径进行裁剪，&lt;code&gt;-c&lt;/code&gt; 表示删减的是字符（Characters），&lt;code&gt;6-&lt;/code&gt; 表示我们删去路径的前 6 个字符（即：&lt;code&gt;.git&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rev&lt;/code&gt;：将处理好的字符串反转回来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/10/29/KDFIBpGXTmcz8qv.png&#34; alt=&#34;裁剪路径&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;-xargs--git-pull&#34;&gt;利用 &lt;code&gt;xargs&lt;/code&gt; 执行带参数的 &lt;code&gt;git pull&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上一步，我们已经提取出来所有包含 &lt;code&gt;.git&lt;/code&gt; 的文件夹，现在我们需要批量的执行 &lt;code&gt;git pull&lt;/code&gt; 来统一拉取仓库。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;xargs -I &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; git -C &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; pull
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于 &lt;code&gt;git&lt;/code&gt; 并不支持传入目录等参数，因此我们需要借助于 &lt;code&gt;xargs&lt;/code&gt; 来给 &lt;code&gt;git&lt;/code&gt; 传入拉取路径。上面的命令简明易懂，就相当于 &lt;code&gt;xargs&lt;/code&gt; 告诉 &lt;code&gt;git&lt;/code&gt; 拉取以上目录下的全部 Git 仓库。我们来看一看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/10/29/oCxk1O9SEP34RhW.gif&#34; alt=&#34;脚本效果&#34;&gt;&lt;/p&gt;
&lt;p&gt;b(￣▽￣)d 👍 成功~&lt;/p&gt;
&lt;h1 id=&#34;-references&#34;&gt;📚 References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@codenameyau/updating-multiple-repos-with-one-command-9768c8cdfe46&#34;&gt;Updating Multiple Repos With One Command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html&#34;&gt;xargs 命令教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
            </item>
        
    </channel>
</rss>
